{
  "version": 3,
  "file": "main.css",
  "sources": [
    "../GLApp.svelte",
    "../App.svelte",
    "../TechApp.svelte",
    "../Controls.svelte",
    "../Keypad.svelte",
    "../Layer.svelte",
    "../Scene.svelte",
    "../Overlay.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport { onMount } from 'svelte';\n\n\texport let title;\n\n\timport * as GL from '@sveltejs/gl';\n\n\texport let color = '#ff3e00';\n\n\tconst data = JSON.parse(document.getElementById('data_in_html').children[0].innerHTML);\n\tconst heightmap = [];\n\tconst gridSizeX = 10;\n\tconst gridSizeZ = 10;\n\n\tfor (let z=0; z < data.length; z++) {\n\t\tconst xx = [];\n\t\tfor (const x of Object.getOwnPropertyNames(data[z])) {\n\t\t\txx.push(data[z][x])\n\t\t}\n\t\theightmap[z] = xx;\n\t}\n\n\tconsole.log(heightmap);\n\n\tlet w = 1;\n\tlet h = 1;\n\tlet d = 1;\n\n\tconst from_hex = hex => parseInt(hex.slice(1), 16);\n\n\tconst light = {};\n\n\tonMount(() => {\n\t\tlet frame;\n\n\t\tconst loop = () => {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tlight.x = 3 * Math.sin(Date.now() * 0.001);\n\t\t\tlight.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n\t\t\tlight.z = 3 * Math.cos(Date.now() * 0.002);\n\t\t};\n\n\t\tloop();\n\n\t\treturn () => cancelAnimationFrame(frame);\n\t});\n</script>\n\n<style>\n\t.controls {\n\t\tfloat: right;\n\t\tposition: relative;\n\t\tmargin: 8px;\n\t\tmargin-top: -160px;\n\t\twidth: 300px;\n\t\theight: 128px;\n\t\tpadding: 1em;\n\t\tbackground-color: rgba(255,255,255,0.7);\n\t\tborder-radius: 2px;\n\t\tz-index: 2;\n\t}\n\n\t@media screen and (max-width: 480px) {\n\t\t.controls {\n\t\t\tmargin-top: 8px;\n\t\t}\n\t}\n\n\t\t.keys {\n\t\tposition: absolute;\n\t\twidth: 256px;\n\t\theight: 256px;\n\t\ttop: calc(50vh - (100vw / 5.75));\n\t\tpadding: 24px;\n\t\tbackground-color: transparent;\n\t}\n\n\t.keys * {\n\t\tpadding: 24px;\n\t}\n</style>\n\n<GL.Scene>\n\t<GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n\t<GL.OrbitControls maxPolarAngle={Math.PI / 2} let:location>\n\t\t<GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n\t</GL.OrbitControls>\n\n\t<GL.AmbientLight intensity={0.3}/>\n\t<GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n\t{#each Array(heightmap.length) as _, k}\n\t\t{#each Array(heightmap[k].length) as _, i}\n\t<!-- box -->\n\t<GL.Mesh geometry={GL.box({ x: 0, y: 0, z: 0 , w: (gridSizeX / heightmap[i].length), h: (1 * heightmap[k][i]), d: (gridSizeZ / heightmap.length) })}\n\t\t\t location={[ (-(gridSizeX / 2) + (i * (gridSizeX / heightmap[0].length))), 0, (-(gridSizeZ / 2) + (k * (gridSizeZ / heightmap.length))) ]}\n\t\t\t rotation={[ 0, 0, 0]}\n\t\t\t scale={[ w, h, d]}\n\t\t\t uniforms={{ color: from_hex(color) }}\n\t/>\n\t\t{/each}\n\t{/each}\n\n\t<!-- spheres -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[ -0.5, 2.4, 1.2 ]}\n\t\t\tscale={0.4}\n\t\t\tuniforms={{ color: 0x123456, alpha: 0.9 }}\n\t\t\ttransparent\n\t/>\n\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[ -1.4, 2.6, 0.2 ]}\n\t\t\tscale={0.6}\n\t\t\tuniforms={{ color: 0x336644, alpha: 1.0 }}\n\t\t\ttransparent\n\t/>\n\n\t<!-- floor -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,0]}\n\t\t\trotation={[-90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- ceiling -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,5.0,0]}\n\t\t\trotation={[90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall1 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,-10.0]}\n\t\t\trotation={[0,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall2 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[10.0,-0.01,0.0]}\n\t\t\trotation={[0,-90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall3 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[-10.0,-0.01,0.0]}\n\t\t\trotation={[0,90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- moving light -->\n\t<GL.Group location={[light.x,light.y,light.z]}>\n\t\t<GL.Mesh\n\t\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\t\tlocation={[0,0.2,0]}\n\t\t\t\tscale={0.1}\n\t\t\t\tuniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n\t\t/>\n\n\t\t<GL.PointLight\n\t\t\t\tlocation={[0,0,0]}\n\t\t\t\tcolor={0xff0000}\n\t\t\t\tintensity={0.6}\n\t\t/>\n\t</GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n\t<label>\n\t\t<input type=\"color\" style=\"height: 40px\" bind:value={color}>\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n\t</label>\n</div>\n",
    "<script>\n\timport { onMount } from 'svelte';\n\n\texport let greeting;\n\n\tlet pin;\n\tlet view;\n\t$: view = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\tlet canvas;\n\n\tonMount(() => {\n\t\tconst ctx = canvas.getContext(\"2d\");\n\t\tctx.fillStyle = \"#00f\";\n\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\tctx.fillStyle = \"#fff\";\n\t\tctx.font = \"20px Arial\";\n\t\tctx.fillText(\"2d Canvas works, too\", 10, 100);\n\n\t\tlet frame;\n\n\t\t(function loop() {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\t\tfor (let p = 0; p < imageData.data.length; p += 4) {\n\t\t\t\tconst i = p / 4;\n\t\t\t\tconst x = i % canvas.width;\n\t\t\t\tconst y = i / canvas.height >>> 0;\n\n\t\t\t\tconst t = window.performance.now();\n\n\t\t\t\tconst r = 64 + (128 * x / canvas.width) + (64 * Math.sin(t / 1000));\n\t\t\t\tconst g = 64 + (128 * y / canvas.height) + (64 * Math.cos(t / 1000));\n\t\t\t\tconst b = 128;\n\n\t\t\t\timageData.data[p + 0] = r;\n\t\t\t\timageData.data[p + 1] = g;\n\t\t\t\timageData.data[p + 2] = b;\n\t\t\t\timageData.data[p + 3] = 255;\n\t\t\t}\n\n\t\t\tctx.putImageData(imageData, 0, 0);\n\t\t}());\n\n\t\treturn () => {\n\t\t\tcancelAnimationFrame(frame);\n\t\t};\n\t});\n</script>\n\n<style>\n\tcanvas {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: #666;\n\t\t-webkit-mask: url(\"../images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t\tmask: url(\"../images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t}\n\t#view {\n\t\ttext-align: center;\n\t}\n</style>\n\n<div id=\"view\">\n\t<h3>{@html greeting}</h3>\n\t<canvas\n\t\t\tbind:this={canvas}\n\t\t\twidth={32}\n\t\t\theight={32}\n\t></canvas>\n</div>\n",
    "<script>\n\timport { onMount } from 'svelte';\n\timport Keypad from './components/Keypad.svelte';\n\n\texport let title;\n\n\tlet pin;\n\tlet view;\n\t$: view = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\timport * as GL from '@sveltejs/gl';\n\n\texport let color = '#ff3e00';\n\tlet w = 1;\n\tlet h = 1;\n\tlet d = 1;\n\n\tconst from_hex = hex => parseInt(hex.slice(1), 16);\n\n\tconst light = {};\n\n\tonMount(() => {\n\t\tlet frame;\n\n\t\tconst loop = () => {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tlight.x = 3 * Math.sin(Date.now() * 0.001);\n\t\t\tlight.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n\t\t\tlight.z = 3 * Math.cos(Date.now() * 0.002);\n\t\t};\n\n\t\tloop();\n\n\t\treturn () => cancelAnimationFrame(frame);\n\t});\n</script>\n\n<style>\n\t.keys {\n\t\ttop: calc(50vh - (100vw / 5.75));\n\t\tright: 0;\n\t\tmargin: 8px;\n\t\tposition: absolute;\n\t\twidth: 256px;\n\t\theight: 256px;\n\t\tpadding: 24px;\n\t\tbackground-color: transparent;\n\t\tz-index: 2;\n\t}\n\n\t.keys * {\n\t\tpadding: 24px;\n\t}\n</style>\n\n<GL.Scene>\n\t<GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n\t<GL.OrbitControls maxPolarAngle={Math.PI / 2} let:location>\n\t\t<GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n\t</GL.OrbitControls>\n\n\t<GL.AmbientLight intensity={0.3}/>\n\t<GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n\t<!-- box -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.box({})}\n\t\t\tlocation={[0,h/2,0]}\n\t\t\trotation={[0,-20,0]}\n\t\t\tscale={[w,h,d]}\n\t\t\tuniforms={{ color: from_hex(color) }}\n\t/>\n\n\t<!-- spheres -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-0.5, 0.4, 1.2]}\n\t\t\tscale={0.4}\n\t\t\tuniforms={{ color: 0x123456, alpha: 0.9 }}\n\t\t\ttransparent\n\t/>\n\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-1.4, 0.6, 0.2]}\n\t\t\tscale={0.6}\n\t\t\tuniforms={{ color: 0x336644, alpha: 1.0 }}\n\t\t\ttransparent\n\t/>\n\n\t<!-- floor -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,0]}\n\t\t\trotation={[-90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- ceiling -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,5.0,0]}\n\t\t\trotation={[90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall1 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,-10.0]}\n\t\t\trotation={[0,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall2 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[10.0,-0.01,0.0]}\n\t\t\trotation={[0,-90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall3 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[-10.0,-0.01,0.0]}\n\t\t\trotation={[0,90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- moving light -->\n\t<GL.Group location={[light.x,light.y,light.z]}>\n\t\t<GL.Mesh\n\t\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\t\tlocation={[0,0.2,0]}\n\t\t\t\tscale={0.1}\n\t\t\t\tuniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n\t\t/>\n\n\t\t<GL.PointLight\n\t\t\t\tlocation={[0,0,0]}\n\t\t\t\tcolor={0xff0000}\n\t\t\t\tintensity={0.6}\n\t\t/>\n\t</GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n\t<label>\n\t\t<input type=\"color\" style=\"height: 40px\" bind:value={color}>\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n\t</label>\n</div>\n\n<div class=\"controls keys\">\n\t<h1 style=\"color: {pin ? '#999' : '#fff'}\">{view}</h1>\n\t<Keypad bind:value={pin} on:submit={handleSubmit}/>\n</div>\n",
    "<script>\n    import {  createEventDispatcher } from 'svelte';\n\n    export let title;\n    export let color = '#ff3e00';\n\n    export let options = [];\n    export let rangeOptions = [];\n    export let rangeValues = [];\n\n    export let viewLocation, viewTarget;\n\n    let dispatch = createEventDispatcher();\n\n    let formatPlayTime = (time) => \"\" + (new Date(time).toString());\n\n    let mouse_x = 0, mouse_y = 0, mouse_down = false, mouse_disabled = false;\n\n    let navContext;\n\n    let sinceLastMovementEvent = 0;\n\n    let isFullscreen = false;\n\n    let toggleFullscreen = function () {};\n\n    export const init = function () {\n        console.log(\"Initializing Controls...\");\n\n        document.querySelectorAll('.controls h4').forEach(c => {\n            console.log(c);\n\n            const scrollLength = 3 * window.innerHeight / 4;\n            c.addEventListener('click', function (event) {\n                let scrollInterval = 33;\n                let scrollTime = 533;\n                let scrolled = 0\n\n                const startScroll = setInterval(function () {\n                    if (scrolled < scrollLength) {\n                        scroll({top: scrolled, left: 0});\n                    }\n                    scrolled += Math.floor(scrollLength / (scrollTime / scrollInterval));\n                }, scrollInterval);\n\n            });\n\n            c.title = \"Click To See Article\";\n        });\n\n        document.querySelectorAll('canvas').forEach(c => {\n            console.log(c);\n\n            toggleFullscreen = () => {\n                if (!isFullscreen) {\n                    isFullscreen = true;\n                    c.parentElement.className += \" fullscreen\"\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className += \" fullscreen\";\n                    }\n                } else {\n                    isFullscreen = false;\n                    c.parentElement.className = c.parentElement.className.replace(\"fullscreen\", '');\n                    for (const control of document.getElementsByClassName(\"controls\")) {\n                        control.className = control.className.replace(\"fullscreen\", '');\n                    }\n                }\n            }\n\n            c.addEventListener('keydown', function (event) {\n                const kbEvent = (event || window['event']); // cross-browser shenanigans\n\n                if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n\n                    // console.log(kbEvent);\n\n                    sinceLastMovementEvent = (new Date()).getTime();\n\n                    if (kbEvent['keyCode'] === 32) { // spacebar\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 38 || kbEvent['keyCode'] === 87) { // up || W\n\n                        dispatch('forward');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 40 || kbEvent['keyCode'] === 83) { // down || S\n\n                        dispatch('backward');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 37 || kbEvent['keyCode'] === 65) { // left || A\n\n                        dispatch('left');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else if (kbEvent['keyCode'] === 39 || kbEvent['keyCode'] === 68) { // right || D\n\n                        dispatch('right');\n\n                        kbEvent.preventDefault();\n\n                        return true;\n\n                    } else {\n                        console.log('Keyboard Event: ', kbEvent['keyCode']);\n\n                        return false;\n                    }\n                }\n            });\n\n            c.addEventListener('wheel', function (event) {\n                const wheelEvent = (event || window['event']);\n\n                if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {\n\n                    sinceLastMovementEvent = (new Date()).getTime();\n\n                    if (wheelEvent.deltaY < 0) {\n                        dispatch('up');\n                    } else if (wheelEvent.deltaY > 0) {\n                        dispatch('down');\n                    }\n                }\n\n                // wheelEvent.preventDefault();\n            });\n        });\n    };\n</script>\n\n<style>\n    .controls h4 {\n        color: black;\n        cursor: pointer;\n        pointer-events: all;\n    }\n</style>\n\n<div class=\"controls right\">\n\n    <h4>{ title }</h4>\n\n    {#if (options['labels'].length > 0 && options['values'].length > 0)}\n        {#each options['values'] as option, o}\n            <label>\n                <input type=\"checkbox\" bind:checked={option.value} /> {options['labels'][o]}\n            </label><br />\n        {/each}\n    {/if}\n\n    {#if (!!color)}\n        <label>\n            <input type=\"color\" style=\"height: 40px\" bind:value={color}>\n        </label>\n    {/if}\n\n    {#if (rangeOptions['labels'].length > 0 && rangeValues.length > 0)}\n        {#each rangeValues as option, o}\n            <label>\n                <input type=\"range\" bind:value={option} min={rangeOptions['min'][o]} max={rangeOptions['max'][o]} step={rangeOptions['step'][o]} /><br />\n                {rangeOptions['labels'][o]}({option})\n            </label><br />\n        {/each}\n    {/if}\n\n    <label>\n        <button on:click=\"{toggleFullscreen}\">{((isFullscreen) ? 'minimize' : 'maximize')}</button>\n    </label>\n\n</div>\n",
    "<script>\n\timport { createEventDispatcher } from 'svelte';\n\n\texport let value = '';\n\n\tconst dispatch = createEventDispatcher();\n\n\tconst select = num => () => value += num;\n\tconst clear  = () => value = '';\n\tconst submit = () => dispatch('submit');\n</script>\n\n<style>\n\t.keypad {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(3, 5em);\n\t\tgrid-template-rows: repeat(4, 3em);\n\t\tgrid-gap: 0.5em\n\t}\n\n\tbutton {\n\t\tmargin: 0\n\t}\n</style>\n\n<div class=\"keypad\">\n\t<button on:click={select(1)}>1</button>\n\t<button on:click={select(2)}>2</button>\n\t<button on:click={select(3)}>3</button>\n\t<button on:click={select(4)}>4</button>\n\t<button on:click={select(5)}>5</button>\n\t<button on:click={select(6)}>6</button>\n\t<button on:click={select(7)}>7</button>\n\t<button on:click={select(8)}>8</button>\n\t<button on:click={select(9)}>9</button>\n\n\t<button disabled={!value} on:click={clear}>clear</button>\n\t<button on:click={select(0)}>0</button>\n\t<button disabled={!value} on:click={submit}>submit</button>\n</div>",
    "<script>\n\timport { get_layer, set_layer } from '../internal/index.mjs';\n\n\texport let index = undefined;\n\n\tset_layer(get_layer().add_child(index));\n</script>\n\n<div class=\"layer\">\n\t<slot></slot>\n</div>\n\n<style>\n\t/* for overlays, create a stacking context */\n\t.layer {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n</style>",
    "<script context=\"module\">\n\timport { readable } from 'svelte/store';\n\n\tfunction is_intersecting(el) {\n\t\t// TODO this shouldn't be necessary. But the initial value\n\t\t// of entry.isIntersecting in an IO can be incorrect, it\n\t\t// turns out? need to investigate further\n\t\tconst bcr = el.getBoundingClientRect();\n\n\t\treturn (\n\t\t\tbcr.bottom > 0 &&\n\t\t\tbcr.right  > 0 &&\n\t\t\tbcr.top    < window.innerHeight &&\n\t\t\tbcr.left   < window.innerWidth\n\t\t);\n\t}\n\n\tfunction get_visibility(node) {\n\t\treturn readable(false, set => {\n\t\t\tif (typeof IntersectionObserver !== 'undefined') {\n\t\t\t\tconst observer = new IntersectionObserver(entries => {\n\t\t\t\t\t// set(entries[0].isIntersecting);\n\t\t\t\t\tset(is_intersecting(node));\n\t\t\t\t});\n\n\t\t\t\tobserver.observe(node);\n\t\t\t\treturn () => observer.unobserve(node);\n\t\t\t}\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tfunction handler() {\n\t\t\t\t\tconst { top, bottom } = node.getBoundingClientRect();\n\t\t\t\t\tset(bottom > 0 && top < window.innerHeight);\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('scroll', handler);\n\t\t\t\twindow.addEventListener('resize', handler);\n\n\t\t\t\treturn () => {\n\t\t\t\t\twindow.removeEventListener('scroll', handler);\n\t\t\t\t\twindow.removeEventListener('resize', handler);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n</script>\n\n<script>\n\timport { setContext, onMount, onDestroy, tick } from 'svelte';\n\timport { writable } from 'svelte/store';\n\timport { RENDERER, LAYER, PARENT, CAMERA, create_layer } from '../internal/index.mjs';\n\timport { create_worker, process_color } from '../internal/utils.mjs';\n\timport * as mat4 from 'gl-matrix/mat4';\n\timport * as vec3 from 'gl-matrix/vec3';\n\n\texport let background = [1, 1, 1];\n\texport let backgroundOpacity = 1;\n\texport let fog = undefined;\n\texport let pixelRatio = undefined;\n\n\tconst use_fog = 'fog' in $$props;\n\n\t$: bg = process_color(background);\n\n\tlet canvas;\n\tlet visible = writable(false);\n\tlet pending = false;\n\tlet update_scheduled = false;\n\tlet w;\n\tlet h;\n\n\texport let gl; // WebGL2RenderingContext\n\texport let process_extra_shader_components; // (gl, material) => {}\n\tlet draw = () => {};\n\tlet camera_stores = {\n\t\tcamera_matrix: writable(),\n\t\tview: writable(),\n\t\tprojection: writable()\n\t};\n\n\tconst invalidate = typeof window !== 'undefined'\n\t\t? () => {\n\t\t\tif (!update_scheduled) {\n\t\t\t\tupdate_scheduled = true;\n\t\t\t\trequestAnimationFrame(draw);\n\t\t\t}\n\t\t}\n\t\t: () => {};\n\n\tconst width = writable(1);\n\tconst height = writable(1);\n\n\tconst root_layer = create_layer(0, invalidate);\n\n\tconst default_camera = { /* TODO */ };\n\tlet camera = default_camera;\n\tconst num_lights = 8;\n\n\tconst meshes = [];\n\n\t// lights\n\tconst lights = {\n\t\tambient: [],\n\t\tdirectional: [],\n\t\tpoint: []\n\t};\n\n\tfunction add_to(array) {\n\t\treturn fn => {\n\t\t\tarray.push(fn);\n\t\t\tinvalidate();\n\n\t\t\tonDestroy(() => {\n\t\t\t\tconst i = array.indexOf(fn);\n\t\t\t\tif (~i) array.splice(i, 1);\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t}\n\t}\n\n\tconst targets = new Map();\n\tlet camera_position_changed_since_last_render = true;\n\n\tconst scene = {\n\t\tdefines: [\n\t\t\t`#define NUM_LIGHTS 2\\n` + // TODO configure this\n\t\t\t`#define USE_FOG ${use_fog}\\n`\n\t\t].join(''),\n\n\t\tadd_camera: _camera => {\n\t\t\tif (camera && camera !== default_camera) {\n\t\t\t\tthrow new Error(`A scene can only have one camera`);\n\t\t\t}\n\n\t\t\tcamera = _camera;\n\t\t\tinvalidate();\n\n\t\t\t// TODO this is garbage\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\t\t\tcamera_stores.view.set(camera.view);\n\n\t\t\tonDestroy(() => {\n\t\t\t\tcamera = default_camera;\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t},\n\n\t\tupdate_camera: camera => {\n\t\t\t// for overlays\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.view.set(camera.view);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\n\t\t\tcamera_position_changed_since_last_render = true;\n\t\t\tinvalidate();\n\t\t},\n\n\t\tadd_directional_light: add_to(lights.directional),\n\t\tadd_point_light: add_to(lights.point),\n\t\tadd_ambient_light: add_to(lights.ambient),\n\n\t\tget_target(id) {\n\t\t\tif (!targets.has(id)) targets.set(id, writable(null));\n\t\t\treturn targets.get(id);\n\t\t},\n\n\t\tinvalidate,\n\n\t\t...camera_stores,\n\n\t\twidth,\n\t\theight\n\t};\n\n\tsetContext(RENDERER, scene);\n\tsetContext(LAYER, root_layer);\n\n\tconst origin = mat4.identity(mat4.create());\n\tconst ctm = writable(origin);\n\tsetContext(PARENT, {\n\t\tget_matrix_world: () => origin,\n\t\tctm: { subscribe: ctm.subscribe }\n\t});\n\n\tonMount(() => {\n\t\tscene.canvas = canvas;\n\t\tgl = scene.gl = canvas.getContext('webgl2');\n\t\tvisible = get_visibility(canvas);\n\n\t\tgl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n\t\t// const extensions = [\n\t\t// \t'OES_element_index_uint',\n\t\t// \t'OES_standard_derivatives'\n\t\t// ];\n\t\t//\n\t\t// extensions.forEach(name => {\n\t\t// \tconst ext = gl.getExtension(name);\n\t\t// \tif (!ext) {\n\t\t// \t\tthrow new Error(`Unsupported extension: ${name}`);\n\t\t// \t}\n\t\t// });\n\n\t\tdraw = force => {\n\t\t\tif (!camera) return; // TODO make this `!ready` or something instead\n\n\t\t\tif (dimensions_need_update) {\n\t\t\t\tconst DPR = pixelRatio || window.devicePixelRatio || 1;\n\t\t\t\tcanvas.width = $width * DPR;\n\t\t\t\tcanvas.height = $height * DPR;\n\t\t\t\tgl.viewport(0, 0, $width * DPR, $height * DPR);\n\n\t\t\t\tdimensions_need_update = false;\n\t\t\t}\n\n\t\t\tupdate_scheduled = false;\n\n\t\t\tif (!$visible && !force) {\n\t\t\t\tpending = true;\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\tpending = false;\n\n\t\t\t// gl.clearColor(...bg, backgroundOpacity);\n\t\t\t// gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.enable(gl.CULL_FACE);\n\t\t\tgl.enable(gl.DEPTH_TEST);                               // Enable depth testing\n\t\t\tgl.depthFunc(gl.LEQUAL);                                // Near things obscure far things\n\n\t\t\t// Clear the canvas before we start drawing on it.\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\t// calculate total ambient light\n\t\t\tconst ambient_light = lights.ambient.reduce((total, { color, intensity }) => {\n\t\t\t\treturn [\n\t\t\t\t\tMath.min(total[0] + color[0] * intensity, 1),\n\t\t\t\t\tMath.min(total[1] + color[1] * intensity, 1),\n\t\t\t\t\tMath.min(total[2] + color[2] * intensity, 1)\n\t\t\t\t];\n\t\t\t}, new Float32Array([0, 0, 0]));\n\n\t\t\tlet previous_program;\n\n\t\t\tlet previous_state = {\n\t\t\t\t[gl.DEPTH_TEST]: null,\n\t\t\t\t[gl.CULL_FACE]: null\n\t\t\t};\n\n\t\t\tconst enable = (key, enabled) => {\n\t\t\t\tif (previous_state[key] !== enabled) {\n\t\t\t\t\tif (enabled) gl.enable(key);\n\t\t\t\t\telse gl.disable(key);\n\n\t\t\t\t\tprevious_state[key] = enabled;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction render_mesh({\n\t\t\t\tmodel,\n\t\t\t\tmodel_inverse_transpose,\n\t\t\t\tgeometry,\n\t\t\t\tmaterial,\n\t\t\t\tdepthTest,\n\t\t\t\tdoubleSided\n\t\t\t}) {\n\t\t\t\t// TODO should this even be possible?\n\t\t\t\tif (!material) return;\n\n\t\t\t\tenable(gl.DEPTH_TEST, depthTest !== false);\n\t\t\t\tenable(gl.CULL_FACE, doubleSided !== true);\n\n\t\t\t\tgl.blendFuncSeparate(\n\t\t\t\t\tgl.SRC_ALPHA, // source rgb\n\t\t\t\t\tgl.ONE_MINUS_SRC_ALPHA, // dest rgb\n\t\t\t\t\tgl.SRC_ALPHA, // source alpha\n\t\t\t\t\tgl.ONE // dest alpha\n\t\t\t\t);\n\n\t\t\t\t// set attributes\n\t\t\t\tgeometry.set_attributes(gl);\n\n\t\t\t\tif (material.program !== previous_program) {\n\t\t\t\t\tprevious_program = material.program;\n\n\t\t\t\t\t// TODO move logic to the mesh/material?\n\t\t\t\t\tgl.useProgram(material.program);\n\n\t\t\t\t\t// set built-ins\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.AMBIENT_LIGHT, ambient_light);\n\n\t\t\t\t\tif (use_fog) {\n\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.FOG_COLOR, bg);\n\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.FOG_DENSITY, fog);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.DIRECTIONAL_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.directional[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].direction, light.direction);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.DIRECTIONAL_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.POINT_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.point[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].location, light.location);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.POINT_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.CAMERA_WORLD_POSITION, camera.world_position);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.VIEW, false, camera.view);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.PROJECTION, false, camera.projection);\n\t\t\t\t}\n\n\t\t\t\t// set mesh-specific built-in uniforms\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL, false, model);\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL_INVERSE_TRANSPOSE, false, model_inverse_transpose);\n\n\t\t\t\tif (typeof process_extra_shader_components == 'function') {\n\t\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\t\tmaterial.apply_uniforms(gl, null, model, process_extra_shader_components);\n\n\t\t\t\t} else {\n\t\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\t\tmaterial.apply_uniforms(gl);\n\t\t\t\t}\n\n\t\t\t\t// draw\n\t\t\t\tif (geometry.index) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.buffers.__index);\n\t\t\t\t\tgl.drawElements(gl[geometry.primitive], geometry.index.length, gl.UNSIGNED_INT, 0);\n\t\t\t\t} else {\n\t\t\t\t\t// if (geometry.primitive === 'POINTS') {\n\t\t\t\t\t// \tconsole.log(\"If \", (gl[geometry.primitive] === gl.POINTS));\n\t\t\t\t\t// \tconsole.log(\"Draw gl.POINTS for \" + geometry.count + \" point(s)\" );\n\t\t\t\t\t// }\n\t\t\t\t\tconst primitiveType = gl[geometry.primitive];\n\t\t\t\t\tgl.drawArrays(primitiveType, 0, geometry.count);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction render_layer(layer) {\n\t\t\t\tif (layer.needs_sort) {\n\t\t\t\t\tlayer.child_layers.sort((a, b) => a.index - b.index);\n\t\t\t\t\tlayer.needs_sort = false;\n\t\t\t\t}\n\n\t\t\t\tgl.depthMask(true);\n\t\t\t\tgl.clearDepth(1.0);\n\t\t\t\tgl.clear(gl.DEPTH_BUFFER_BIT);\n\n\t\t\t\tfor (let i = 0; i < layer.meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.meshes[i]);\n\t\t\t\t}\n\n\t\t\t\t// TODO sort transparent meshes, furthest to closest\n\t\t\t\tgl.depthMask(false);\n\n\t\t\t\tif (camera_position_changed_since_last_render || layer.needs_transparency_sort) {\n\t\t\t\t\tsort_transparent_meshes(layer.transparent_meshes);\n\t\t\t\t\tlayer.needs_transparency_sort = false;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.transparent_meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.transparent_meshes[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.child_layers.length; i += 1) {\n\t\t\t\t\trender_layer(layer.child_layers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender_layer(root_layer);\n\t\t\tcamera_position_changed_since_last_render = false;\n\t\t};\n\n\t\t// for some wacky reason, Adblock Plus seems to prevent the\n\t\t// initial dimensions from being correctly reported\n\t\tconst timeout = setTimeout(() => {\n\t\t\t$width = canvas.clientWidth;\n\t\t\t$height = canvas.clientHeight;\n\t\t});\n\n\t\ttick().then(() => draw(true));\n\n\t\treturn () => {\n\t\t\tgl.getExtension('WEBGL_lose_context').loseContext();\n\t\t\tclearTimeout(timeout);\n\t\t};\n\t});\n\n\tconst sort_transparent_meshes = meshes => {\n\t\tif (meshes.length < 2) return;\n\n\t\tconst lookup = new Map();\n\t\tconst out = new Float32Array(16);\n\n\t\tmeshes.forEach(mesh => {\n\t\t\tconst z = mat4.multiply(out, camera.view, mesh.model)[14];\n\t\t\tlookup.set(mesh, z);\n\t\t});\n\n\t\tmeshes.sort((a, b) => lookup.get(a) - lookup.get(b));\n\t};\n\n\tlet dimensions_need_update = true;\n\n\tconst update_dimensions = () => {\n\t\tdimensions_need_update = true;\n\t\tinvalidate();\n\t};\n\n\t$: ($width, $height, update_dimensions());\n\t$: (background, backgroundOpacity, fog, scene.invalidate());\n\t$: if ($visible && pending) scene.invalidate();\n</script>\n\n<style>\n\t.container, canvas {\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: block;\n\t\toverflow: hidden;\n\t}\n</style>\n\n<div class=\"container\" bind:clientWidth={$width} bind:clientHeight={$height}>\n\t<canvas bind:this={canvas}></canvas>\n\n\t{#if gl}\n\t\t<slot width={$width} height={$height}></slot>\n\t{/if}\n</div>\n",
    "<script>\n\timport Point from './Point.svelte';\n\n\texport let location;\n\texport let direction = undefined;\n\texport let snap = false;\n\n\t$: px = n => `${snap ? Math.round(n) : n}px`;\n</script>\n\n<Point {location} {direction} let:x let:y let:vector>\n\t<span\n\t\tclass=\"overlay\"\n\t\tstyle=\"transform: translate3d({px(x)}, {px(y)}, 0)\"\n\t>\n\t\t<slot vector={vector}></slot>\n\t</span>\n</Point>\n\n<style>\n\t.overlay {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t\twill-change: transform;\n\t}\n</style>"
  ],
  "names": [],
  "mappings": "AAkDC,SAAS,eAAC,CAAC,AACV,KAAK,CAAE,KAAK,CACZ,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACrC,SAAS,eAAC,CAAC,AACV,UAAU,CAAE,GAAG,AAChB,CAAC,AACF,CAAC;ACVD,MAAM,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,IAAI,CACtB,YAAY,CAAE,IAAI,gCAAgC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAC1F,IAAI,CAAE,IAAI,gCAAgC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,AACnF,CAAC,AACD,KAAK,eAAC,CAAC,AACN,UAAU,CAAE,MAAM,AACnB,CAAC;ACvBD,KAAK,4BAAC,CAAC,AACN,GAAG,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAChC,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,GAAG,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,AACX,CAAC,AAED,mBAAK,CAAC,cAAE,CAAC,AACR,OAAO,CAAE,IAAI,AACd,CAAC;ACwFE,wBAAS,CAAC,EAAE,eAAC,CAAC,AACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,OAAO,CACf,cAAc,CAAE,GAAG,AACvB,CAAC;ACxIJ,OAAO,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CACrC,kBAAkB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAClC,QAAQ,CAAE,KAAK;CAChB,CAAC,AAED,MAAM,cAAC,CAAC,AACP,MAAM,CAAE,CAAC;CACV,CAAC;ACRD,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,AACR,CAAC;AC6ZD,wBAAU,CAAE,MAAM,cAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,MAAM,AACjB,CAAC;ACjaD,QAAQ,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,WAAW,CAAE,IAAI,CACjB,gBAAgB,CAAE,IAAI,CACtB,WAAW,CAAE,SAAS,AACvB,CAAC"
}